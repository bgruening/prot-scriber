/// Represenation of a set of biological sequences, e.g. a gene family generated by sequence
/// similarity based clustering.
#[derive(Debug, Clone, Default)]
pub struct SeqFamily {
    /// The biological sequence identifiers this SeqFamily comprises:
    pub query_ids: Vec<String>,
    /// Those Query-Identifiers for which all input sequence similarity search result files have
    /// produced data. So in other words those Query-IDs that are ready to be used as input for the
    /// generation of a human readable description:
    pub query_ids_with_complete_data: Vec<usize>,
}

impl SeqFamily {
    /// Creates and empty (`Default`) instance of struct SeqFamily.
    pub fn new() -> SeqFamily {
        Default::default()
    }

    /// Returns `true` if and only if all query identifiers in argument `self.query_ids` are
    /// contained in `self.query_ids_with_complete_data`, false otherwise.
    ///
    /// # Arguments
    ///
    /// * `&self` - a reference to an instance of SeqFamily
    pub fn all_query_data_complete(&self) -> bool {
        (0..(self.query_ids.len()))
            .into_iter()
            .all(|indx| self.query_ids_with_complete_data.contains(&indx))
    }

    pub fn mark_query_id_with_complete_data(&mut self, query_id: &String) {
        let query_indx = self
            .query_ids
            .iter()
            .position(|qid| *qid == *query_id)
            .unwrap();
        self.query_ids_with_complete_data.push(query_indx);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn all_query_data_complete_works() {
        let mut sf1 = SeqFamily::new();
        assert!(sf1.all_query_data_complete());
        sf1.query_ids.push("Query1".to_string());
        sf1.query_ids.push("Query2".to_string());
        sf1.query_ids.push("Query3".to_string());
        assert!(!sf1.all_query_data_complete());
        sf1.query_ids_with_complete_data.push(0);
        sf1.query_ids_with_complete_data.push(1);
        assert!(!sf1.all_query_data_complete());
        sf1.query_ids_with_complete_data.push(2);
        assert!(sf1.all_query_data_complete());
    }
}
